# Design: Deployment на VDS с Docker

## Context

Необходимо развернуть Telegram бот на VDS для production использования. Текущая Docker конфигурация предназначена для разработки и требует доработки для безопасного и надежного production деплоя.

Ключевые требования:
- Полная контейнеризация (бот + PostgreSQL)
- Автоматический запуск при перезагрузке сервера
- Безопасное хранение секретов
- Логирование с ротацией
- Регулярные бэкапы базы данных
- Простота обновления

## Goals / Non-Goals

### Goals
- Production-ready Docker конфигурация
- Автоматизированный деплой одной командой
- Systemd интеграция для автозапуска
- Централизованное логирование
- Автоматические бэкапы БД
- Документация для деплоя

### Non-Goals
- Kubernetes/оркестрация (v1 - single VDS)
- CI/CD pipeline (v1 - ручной деплой)
- Мониторинг метрик (Prometheus/Grafana)
- Load balancing (single instance)
- SSL/HTTPS (Telegram Bot API не требует)

## Decisions

### 1. Разделение dev/prod конфигураций
**Решение**: Создать отдельный `docker-compose.prod.yml` для production.

**Обоснование**:
- Dev: expose порты, volume mounts для hot-reload
- Prod: закрытые порты, оптимизированные образы, resource limits

**Альтернативы**:
- Один docker-compose с переменными окружения - сложнее поддерживать
- Разные ветки git - излишне для простого проекта

### 2. Systemd для автозапуска
**Решение**: Создать systemd service для управления Docker Compose.

**Обоснование**:
- Стандартный способ для Linux серверов
- Автоматический запуск при перезагрузке
- Интеграция с journald для логов
- Простое управление: `systemctl start/stop/restart`

**Альтернативы**:
- Cron @reboot - менее надежно
- Docker restart policy alone - недостаточно при перезагрузке хоста

### 3. Логирование: JSON file driver с ротацией
**Решение**: Использовать Docker logging driver `json-file` с ограничениями.

**Обоснование**:
- Встроенный в Docker, не требует дополнительных сервисов
- Автоматическая ротация (max-size, max-file)
- Доступ через `docker logs`
- Интеграция с journald через systemd

**Конфигурация**:
```yaml
logging:
  driver: json-file
  options:
    max-size: "10m"
    max-file: "3"
```

**Альтернативы**:
- syslog - требует настройки syslog daemon
- fluentd/loki - избыточно для single instance

### 4. Бэкапы: pg_dump в volume
**Решение**: Скрипт backup.sh с pg_dump в Docker volume.

**Обоснование**:
- Простота: один скрипт
- Не требует доступа к хосту PostgreSQL
- Можно запускать через cron
- Бэкапы хранятся в volume, легко копировать

**Формат**:
```bash
docker exec postgres pg_dump -U user dbname > backup_$(date +%Y%m%d_%H%M%S).sql
```

**Альтернативы**:
- WAL archiving - сложнее для простого случая
- Внешний backup сервис - дополнительные затраты

### 5. Секреты: .env файл с ограниченными правами
**Решение**: `.env` файл с `chmod 600`, не коммитится в git.

**Обоснование**:
- Простота для single-server deployment
- Docker Compose нативно поддерживает
- Легко обновлять

**Безопасность**:
- `.env` в `.gitignore`
- Только root/deploy user может читать
- `.env.production.example` в репозитории

**Альтернативы**:
- Docker secrets - требует Swarm mode
- HashiCorp Vault - избыточно для простого бота

### 6. Сеть: изолированная bridge network
**Решение**: Создать custom bridge network для контейнеров.

**Обоснование**:
- Изоляция от других контейнеров на хосте
- DNS resolution между контейнерами
- PostgreSQL не expose наружу

**Конфигурация**:
```yaml
networks:
  bot-network:
    driver: bridge
    internal: false
```

### 7. Resource limits
**Решение**: Установить memory и CPU limits для контейнеров.

**Обоснование**:
- Предотвращение OOM на хосте
- Предсказуемая производительность
- Защита от утечек памяти

**Рекомендуемые лимиты**:
```yaml
bot:
  deploy:
    resources:
      limits:
        memory: 512M
        cpus: '0.5'
      reservations:
        memory: 256M

postgres:
  deploy:
    resources:
      limits:
        memory: 1G
        cpus: '1.0'
      reservations:
        memory: 512M
```

## Risks / Trade-offs

### Risk 1: Потеря данных при сбое
**Описание**: Если VDS выйдет из строя, данные в volume могут быть потеряны.

**Митигация**:
- Регулярные бэкапы (cron каждые 6 часов)
- Копирование бэкапов на внешнее хранилище (S3, другой сервер)
- Документировать процесс восстановления

### Risk 2: Downtime при обновлении
**Описание**: При обновлении бота будет кратковременный downtime.

**Митигация v1**: Принять downtime 1-2 минуты (приемлемо для бота напоминаний).

**Митигация v2** (будущее): Blue-green deployment с двумя инстансами.

### Risk 3: Забытые секреты в .env
**Описание**: Пользователь может случайно закоммитить .env с секретами.

**Митигация**:
- `.env` в `.gitignore`
- Pre-commit hook для проверки
- Документация с предупреждениями
- `.env.production.example` без реальных значений

### Risk 4: Переполнение диска логами
**Описание**: Логи могут заполнить диск при высокой активности.

**Митигация**:
- Ротация логов Docker (max-size: 10m, max-file: 3)
- Мониторинг свободного места (можно добавить скрипт)
- Документировать команды очистки

## Migration Plan

### Этап 1: Подготовка VDS
1. Установить Docker и Docker Compose
2. Создать пользователя для деплоя
3. Настроить SSH ключи
4. Установить git

### Этап 2: Первичный деплой
1. Клонировать репозиторий на VDS
2. Создать `.env` с production значениями
3. Запустить `./deploy.sh`
4. Проверить работу бота
5. Настроить systemd service
6. Настроить cron для бэкапов

### Этап 3: Проверка
1. Протестировать автозапуск (reboot VDS)
2. Протестировать бэкап и restore
3. Проверить логи
4. Протестировать обновление версии

### Rollback
1. Остановить контейнеры: `docker-compose -f docker-compose.prod.yml down`
2. Восстановить из бэкапа: `./restore.sh <backup_file>`
3. Запустить предыдущую версию: `git checkout <prev_tag> && ./deploy.sh`

## Open Questions

1. **Частота бэкапов**: Каждые 6 часов достаточно или нужно чаще?
   - Предложение: 6 часов для v1, можно настроить через cron

2. **Хранение бэкапов**: Сколько бэкапов хранить локально?
   - Предложение: Последние 7 дней (28 бэкапов по 6 часов)

3. **Мониторинг**: Нужны ли алерты при падении бота?
   - Предложение: v2 - можно добавить healthcheck endpoint + UptimeRobot

4. **Обновления**: Автоматические или ручные?
   - Предложение: v1 - ручные через `git pull && ./deploy.sh`
