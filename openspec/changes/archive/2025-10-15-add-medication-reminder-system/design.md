# Design: Система напоминаний о приеме таблеток

## Context

Проект требует добавления автоматизированной системы напоминаний с поддержкой работы в группах Telegram. Система должна интегрироваться с существующей архитектурой (grammY + Prisma + PostgreSQL) и обеспечивать надежную доставку напоминаний по расписанию.

Ключевые ограничения:
- Бот работает в группах Telegram, где может быть много пользователей
- Необходима точная отправка напоминаний по времени
- Требуется отслеживание подтверждений и повторных напоминаний
- Шаблоны сообщений управляются через базу данных

## Goals / Non-Goals

### Goals
- Автоматическая отправка напоминаний по настроенному расписанию
- Поддержка работы в группах с идентификацией пользователей
- Система подтверждения через inline-кнопки
- Повторные напоминания при отсутствии подтверждения
- Гибкое управление расписанием (CRUD операции)
- Шаблоны сообщений в базе данных

### Non-Goals
- Множественные расписания для разных типов таблеток (v1)
- Статистика и аналитика приема таблеток (v1)
- Push-уведомления вне Telegram
- Интеграция с медицинскими сервисами
- Мобильное приложение

## Decisions

### 1. Планировщик задач: node-cron
**Решение**: Использовать библиотеку `node-cron` для планирования отправки напоминаний.

**Обоснование**:
- Простая интеграция с Node.js
- Поддержка cron-синтаксиса для гибкого расписания
- Легковесная библиотека без внешних зависимостей
- Работает в памяти процесса (подходит для single-instance deployment)

**Альтернативы**:
- Bull/BullMQ (Redis-based) - избыточно для текущего масштаба, требует Redis
- Agenda (MongoDB-based) - требует MongoDB, излишняя сложность
- node-schedule - похожий функционал, но node-cron более популярен

**Ограничения**: При горизонтальном масштабировании потребуется переход на распределенную очередь задач.

### 2. Хранение расписаний: cron-выражения в БД
**Решение**: Хранить расписание в виде массива времен (HH:MM) и частоты в днях, генерировать cron-выражения программно.

**Обоснование**:
- Простота для пользователя (указывает время и частоту)
- Гибкость для будущих расширений
- Легко валидировать и отображать в UI

**Пример**: `times: ["09:00", "14:00", "21:00"]` + `frequency: 1` (каждый день)

### 3. Идентификация в группах: chatId + userId
**Решение**: Хранить как `chatId` (ID группы), так и `userId` (ID пользователя) для каждого расписания.

**Обоснование**:
- Один пользователь может иметь разные расписания в разных группах
- Позволяет отправлять напоминания в контексте конкретной группы
- Упрощает управление правами доступа

### 4. Повторные напоминания: отложенная задача
**Решение**: При отсутствии подтверждения создавать отложенную задачу на повторное напоминание через N минут.

**Обоснование**:
- Простая реализация через setTimeout
- Конфигурируемый интервал повторения
- Ограниченное количество повторов (например, 3 раза)

**Параметры**:
- Интервал: 15 минут (конфигурируемо)
- Максимум повторов: 3

### 5. Inline-кнопки: callback_data с уникальным ID
**Решение**: Использовать `callback_data` формата `confirm_reminder:{reminderId}` для идентификации напоминания.

**Обоснование**:
- Стандартный подход в Telegram Bot API
- Позволяет точно идентифицировать, какое напоминание подтверждается
- Поддержка нескольких активных напоминаний одновременно

### 6. Архитектура: модульная структура
**Решение**: Разделить код на модули:
```
src/
├── handlers/
│   ├── commands.ts      # Обработчики команд
│   └── callbacks.ts     # Обработчики callback-кнопок
├── services/
│   ├── scheduleService.ts   # Бизнес-логика расписаний
│   ├── reminderService.ts   # Бизнес-логика напоминаний
│   └── templateService.ts   # Работа с шаблонами
├── scheduler/
│   └── cronScheduler.ts     # Планировщик задач
└── utils/
    └── timeUtils.ts         # Утилиты для работы со временем
```

**Обоснование**:
- Разделение ответственности
- Упрощение тестирования
- Легкость поддержки и расширения

## Risks / Trade-offs

### Risk 1: Потеря задач при перезапуске
**Описание**: node-cron хранит задачи в памяти, при перезапуске бота все задачи теряются.

**Митигация**: 
- При запуске бота загружать все активные расписания из БД и регистрировать cron-задачи
- Хранить статус отправленных напоминаний в БД для восстановления состояния

### Risk 2: Часовые пояса
**Описание**: Пользователи в разных часовых поясах могут получать напоминания в неправильное время.

**Митигация v1**: Использовать серверное время (UTC), документировать это ограничение.

**Митигация v2** (будущее): Добавить поле timezone в User, конвертировать время при создании расписания.

### Risk 3: Масштабирование
**Описание**: При горизонтальном масштабировании (несколько инстансов бота) задачи будут дублироваться.

**Митигация v1**: Запускать один инстанс бота (достаточно для текущих требований).

**Митигация v2** (будущее): Переход на Bull/BullMQ с Redis для распределенной очереди.

### Risk 4: Спам в группах
**Описание**: Множество пользователей с напоминаниями могут создавать много сообщений в группе.

**Митигация**: 
- Напоминания отправляются только в группу, где пользователь настроил расписание
- Возможность отключить напоминания командой
- В будущем: опция личных сообщений вместо группы

## Migration Plan

### Этап 1: Подготовка БД
1. Создать новые таблицы через Prisma миграцию:
   - `Schedule` - расписания пользователей
   - `Reminder` - отправленные напоминания
   - `MessageTemplate` - шаблоны сообщений
   - `Confirmation` - подтверждения приема
2. Добавить поля `chatId` в User для поддержки групп
3. Выполнить миграцию: `yarn prisma migrate dev`

### Этап 2: Базовые шаблоны
1. Создать seed-скрипт для добавления дефолтных шаблонов
2. Запустить: `yarn prisma db seed`

### Этап 3: Развертывание
1. Обновить Docker образ
2. Применить миграции в production: `yarn prisma migrate deploy`
3. Перезапустить бот
4. Проверить загрузку расписаний при старте

### Rollback
1. Откатить Docker образ на предыдущую версию
2. Откатить миграции БД: `yarn prisma migrate resolve --rolled-back <migration_name>`
3. Удалить новые таблицы при необходимости

## Open Questions

1. **Лимиты**: Нужно ли ограничивать количество расписаний на пользователя?
   - Предложение: Максимум 1 расписание в v1 (по требованию)

2. **Уведомления администраторов**: Должны ли администраторы группы получать статистику?
   - Предложение: Отложить на v2

3. **Формат времени**: 24-часовой или 12-часовой формат для пользователей?
   - Предложение: 24-часовой (HH:MM), более универсальный

4. **Язык интерфейса**: Только русский или мультиязычность?
   - Предложение: Только русский в v1 (согласно project.md)
